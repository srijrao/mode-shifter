# Start

*2025-08-14*

## Overview

Lay the groundwork for a new Obsidian plugin called "Mode Shifter" that allows users to easily switch between different 'modes' within the app.

Within the plugin, users will be able to define and customize their own modes, defined in the settings. These modes are defined by what folders/files are zipped or unzipped when the mode is activated.

- Normal mode will show all files, normal mode cannot be deleted so that users can always return to it.
- Sizes of files/folders in each mode should be calculated and displayed to the user.
- The plugin should not include exclusions
- 
- User defined modes will allow users to specify which files/folders are visible in that mode
- The archive folder should be a compressed folder that contains all the files from the current mode, so that they don't contribute to the graph, search, etc.

## Implementation Details

DRY code details should be adhered to, not repeating the code unnecessarily. Features should be modular and reusable.

### Tests

Write tests to ensure the functionality of the mode switching, UI changes and file visibility features.

## Implementation Instructions

This document describes how to build, test, and run the Mode Shifter plugin. It includes a small implementation contract, design decisions, recommended file operations (zip/unzip), UI wiring, settings schema, test guidance, and developer commands (PowerShell friendly).

### Quick high-level plan

- Set up developer environment (Node + npm). Install dependencies.
- Implement plugin core: settings, mode definitions, activation/deactivation API, and UI controls.
- Implement file operations: create archive (zip), restore archive (unzip), atomic move/delete semantics.
- Add tests for core utilities.
- Build and load plugin into Obsidian for manual QA.

### Contract (tiny)

- Inputs: Mode definitions (list of file/folder paths, optional include/exclude glob patterns). Archive folder path (relative to vault). Commands from UI or hotkeys to activate modes.
- Outputs: Archive files (zip files placed in archive folder), restored files returned to original locations, plugin settings persisted via Obsidian's data store.
- Error modes: insufficient permissions, missing file(s), partial failure during zip/create, disk full. Plugin must leave vault in a consistent state (no partially deleted content) or create a clear backup/rollback.

### Data shapes / TypeScript interfaces (example)

```ts
interface ModeEntry {
	id: string; // stable id
	name: string;
	include: string[]; // relative paths or globs to include
	exclude?: string[]; // relative paths or globs to exclude
	description?: string;
}

interface ModeShifterSettings {
	archiveFolder: string; // e.g. "Archived Modes"
	modes: ModeEntry[];
	lastActiveModeId?: string;
}
```

### Settings UI

- Provide a settings tab with:
	- Global archive folder path (create if missing).
	- Mode list editor (add/remove/reorder). Each mode lets the user specify include globs or explicit paths and optional exclude globs.
	- Buttons to run: "Preview mode", "Activate mode", "Restore mode".

### Archive strategy (zip-first, atomic)

Goal: When a mode is deactivated, all files that should be hidden are removed from the vault filesystem in a way that Obsidian no longer indexes/parses them, but they remain restorable.

Recommended approach:

1. Create the archive folder in the vault (if not present). Use a folder name from settings (default: "Mode Shifter Archive").
2. For the mode deactivation:
	 - Gather the absolute list of files to archive based on include/exclude rules.
	 - Create a zip using a library such as JSZip or a streaming solution (for large vaults consider node-stream-zip or spawning a native zip command as a last resort). Name the zip with mode name, timestamp, and a short hash.
	 - Write the zip into the archive folder inside the vault (use app.vault.adapter to write binary data).
	 - Verify the zip can be read (quick sanity check: open and list entries).
	 - Only after successful verification, delete the original files from their locations (use app.vault.delete or adapter operations). Deletions should be done in small batches and checkpointed so partial failures can rollback by restoring from the zip.

3. For activation/restoration:
	 - Locate the zip in the archive folder for that mode (by metadata or naming convention).
	 - Extract the zip into a temporary location (or stream files back via app.vault.createBinary) while preserving folder structure.
	 - Verify extraction succeeded, then remove the zip (if desired) or keep it as a backup depending on user preference.

Notes on safety:
- Always create the zip before deleting originals.
- On any error during deletion, abort and provide a clear restore command that will extract the zip back to the original locations.
- Use an operation log (small JSON manifest next to the zip) with original paths and timestamps to simplify rollback.

### Performance and vault indexing

- Zipping and deleting files will make them invisible to Obsidian's index and graph.
- Avoid doing large zips on the main thread. Use async operations and show progress in the UI.

### Edge cases to cover

- Files changed during the archive operation: detect modified time differences and prompt user.
- Vault files currently opened in editors: warn the user and optionally close editors before delete.
- Conflicting paths when restoring (existing files): support three policies — overwrite, skip, create conflict copy.
- Large binary files and very large vaults: provide streaming zipping and progress UI.
- Insufficient disk space: test before deleting originals by estimating zip size (if possible).

### Testing guidance

- Unit tests (vitest or mocha):
	- Utilities: expandGlobsToPaths, generateZipBuffer, writeZipToVault, readManifest.
	- Simulate errors: failed write, failed delete, partial deletes; assert rollback behavior.

- Integration tests:
	- Create a disposable test vault directory in /tests/test-vault.
	- Run the archive flow and assert that archived files are removed and zip exists in archive folder.
	- Run the restore flow and assert files are restored exactly.

Example test checklist:

- happy path: archive -> zip created -> originals removed -> restore -> originals restored
- failure during write: no originals removed
- failure during delete: rollback restores any deleted files from the zip

### file layout for plugin (repo-level)

- `manifest.json` — Obsidian plugin manifest (id, name, version, main, minAppVersion)
- `main.ts` — plugin entry (exports default class extends Plugin)
- `styles.css` — optional UI CSS
- `src/` — TypeScript sources
- `tests/` — unit and integration tests

### Useful code snippets (conceptual)

- Expand globs to file list: use fast-glob or node-glob on top-level vault paths.
- Create zip: JSZip or a streaming zip library. Example concept:

```ts
async function createArchive(files: string[], zipName: string) {
	const zip = new JSZip();
	for (const path of files) {
		const data = await app.vault.adapter.readBinary(path);
		zip.file(path, data);
	}
	const content = await zip.generateAsync({ type: 'uint8array' });
	await app.vault.adapter.writeBinary(join(settings.archiveFolder, zipName), content);
}
```

### How to run locally (developer steps, PowerShell)

1. Install dependencies

```powershell
npm install
```

2. Build (one-time)

```powershell
npm run build
```

3. For iterative development, run the watcher (if configured)

```powershell
npm run dev
```

4. Load into Obsidian for testing

- Copy the plugin folder (the folder containing `manifest.json` and `main.js`) into your vault's `.obsidian/plugins/mode-shifter` folder. Or symlink it for faster dev iteration.
- In Obsidian, open Settings → Community plugins → Disabled → turn off Safe Mode and enable the plugin.

5. Manual QA

- Use the settings UI to create a mode that includes a small set of sample notes. Run "Preview" first to verify files selected. Then run "Activate" and confirm files are archived (zip in archive folder) and removed from vault. Use "Restore" to bring them back.

### Linting, formatting and typecheck

- Keep TypeScript strict. Run:

```powershell
npm run lint
npm run typecheck
```

Add small, focused unit tests and keep builds fast.

### Quality gates (recommended)

- Build: `npm run build` — must succeed.
- Lint/Typecheck: `npm run lint` and `npm run typecheck` must be green.
- Tests: unit tests and integration tests should pass (use `npm test`).

### Next steps / TODO

- Implement settings UI and settings persistence.
- Implement core utilities (globbing, zip create/verify, delete with rollback).
- Add UI for progress and conflict resolution.
- Add unit and integration tests. Create a CI workflow to run tests on PRs.

## Notes

- The approach described aims to keep the vault consistent and user data safe. If you prefer a non-destructive mode, implement an option that moves files into a separate folder (instead of zipping) so users can inspect them before zipping.
- For very large vaults, prefer streaming zippers and consider offloading large file handling to native tools if JS performance becomes a bottleneck.

---

Touch this document as you implement; it should serve as the single source of truth for the plugin developer workflow.